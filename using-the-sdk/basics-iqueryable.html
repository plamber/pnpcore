<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>IQueryable performance considerations | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="IQueryable performance considerations | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/plamber/pnpcore/blob/dev/docs/using-the-sdk/basics-iqueryable.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="iqueryable-performance-considerations"><a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.iqueryable"><code>IQueryable</code></a> performance considerations</h1>

<p>In the <a href="basics-getdata.html#requesting-model-collections">Requesting model collections</a> section you saw quite a lot of different examples of how to query collections. Almost all collections inside PnP Core SDK implement an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.iqueryable"><code>IQueryable</code></a> interface.</p>
<p>Thanks to this you can use LINQ expressions to dynamically filter or asynchronously load collection elements on demand. All your LINQ expressions will be accurately translated to the REST OData query operations (like <code>$filter</code>, <code>$select</code>, <code>$expand</code>, etc).</p>
<p>Having below code:</p>
<pre><code class="lang-csharp">var lists = await context.Web.Lists
  .Where(l =&gt; l.Hidden == false &amp;&amp; l.TemplateType == ListTemplateType.DocumentLibrary)
  .QueryProperties(p =&gt; p.Title, p =&gt; p.TemplateType, p =&gt; p.ContentTypes.QueryProperties(p =&gt; p.Name)).ToListAsync();
</code></pre>
<p>upon execution will be translated to the below REST OData query:</p>
<pre><code class="lang-bash">_api/web/lists?$select=Id,Title,BaseTemplate,ContentTypes/Name,ContentTypes/StringId&amp;$expand=ContentTypes&amp;$filter=(BaseTemplate+eq+101)
</code></pre>
<p>It's a very powerful feature, however let's take a closer look at this technique to avoid some common performance issues.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>The most important rule of <code>IQueryable</code> is that an <code>IQueryable</code> doesn't fire a request when it's declared, but only when it's enumerated over (inside foreach cycle or when calling <code>ToList()</code>/<code>ToListAsync()</code>).</p>
</div>
<h2 id="loading-collections-into-the-pnpcontext">Loading collections into the PnPContext</h2>
<p>Let's have a sample query to get a web's lists:</p>
<p>❌ <em>not efficient:</em></p>
<pre><code class="lang-csharp">// All lists loaded into the context
await context.Web.LoadAsync(p =&gt; p.Lists);

foreach (var list in context.Web.Lists)
{
  // do something with the list here
}
</code></pre>
<p>What's wrong with this code? It works just fine, however it sends two identical HTTP requests to the SharePoint server to get lists (one in <code>LoadAsync(p =&gt; p.Lists)</code> and the second one in the <code>foreach</code> cycle). Why does it happen? Because <code>Lists</code> property implements <code>IQueryable</code>, inside <code>foreach</code> cycle you effectively enumerate the <code>IQueryable</code>, as a result, it sends an HTTP request to get data.</p>
<p>How to fix the code? Use <code>AsRequested()</code>:</p>
<p>✅ <em>better:</em></p>
<pre><code class="lang-csharp">// All lists loaded into the context
await context.Web.LoadAsync(p =&gt; p.Lists);

foreach (var list in context.Web.Lists.AsRequested())
{
  // do something with the list here
}
</code></pre>
<p>As mentioned earlier, <code>AsRequested()</code> method returns an already loaded collection of items, you should use this method to avoid multiple unnecessary HTTP requests. In this case, we enumerate a collection loaded in memory before.</p>
<p>Alternatively, you can also use just one cycle without <code>LoadAsync(p =&gt; p.Lists)</code>:</p>
<p>✅ <em>better:</em></p>
<pre><code class="lang-csharp">await foreach (var list in context.Web.Lists)
{
  // do something with list here
}
</code></pre>
<p>In this case, list collection will be requested at the beginning of the <code>foreach</code> cycle. Do remember though, that if you iterate over collection again somewhere in your code path, an additional request will be sent.</p>
<h2 id="load-related-properties">Load related properties</h2>
<p>The below code has a similar problem with the query efficiency:</p>
<p>❌ <em>not efficient:</em></p>
<pre><code class="lang-csharp">var list = await context.Web.Lists.GetByTitleAsync(&quot;Documents&quot;, l =&gt; l.Fields);
var fields = await list.Fields.Where(l =&gt; l.InternalName.StartsWith(&quot;tax&quot;)).ToListAsync();
</code></pre>
<p>The first line loads a list by title and also loads related property - all list fields. On the second line we again send HTTP request to further filter fields. But what we need instead is to filter already loaded fields:</p>
<pre><code class="lang-csharp">var fields = list.Fields.AsRequested().Where(l =&gt; l.InternalName.StartsWith(&quot;tax&quot;)).ToList();
</code></pre>
<p>To make it even more efficient, you should change it like this:</p>
<p>✅ <em>better:</em></p>
<pre><code class="lang-csharp">var list = await context.Web.Lists.GetByTitleAsync(&quot;Documents&quot;);
var fields = await list.Fields.Where(l =&gt; l.InternalName.StartsWith(&quot;tax&quot;)).ToListAsync();
</code></pre>
<p>It doesn't make sense to load all related fields with the list request. Thus we simply send a separate request with a filter (will be translated to the <code>$filter=startswith</code> OData query) to get desired fields.</p>
<h2 id="cycles-andor-method-calls">Cycles and/or method calls</h2>
<p>Could you guess what's the problem with the below code:</p>
<p>❌ <em>not efficient:</em></p>
<pre><code class="lang-csharp">var filteredList = context.Web.Lists.Where(l =&gt; l.TemplateType == ListTemplateType.DocumentLibrary);

for (int i = 0; i &lt; 10; i++)
{
    DoSmth(filteredList);
}

private bool DoSmth(IEnumerable&lt;IList&gt; lists)
{
    foreach (var list in lists)
    {
        // do smth with list
    }
}
</code></pre>
<p>It also works just fine, however has an issue, that the above code sends 10 HTTP requests to get lists data. The <code>filteredList</code> is an instance of <code>IQueryable&lt;IList&gt;</code>, that's why it doesn't execute the request immediately, but only inside the <code>foreach</code> cycle in the <code>Check</code> function. Every time we visit the function, we send an HTTP request to get lists.</p>
<p>How to fix it? Change the filter query so that it executes immediately using <code>ToList()</code> or <code>ToListAsync()</code> methods:</p>
<p>✅ <em>better:</em></p>
<pre><code class="lang-csharp">var filteredList = await context.Web.Lists.Where(l =&gt; l.TemplateType == ListTemplateType.DocumentLibrary).ToListAsync();
</code></pre>
<p>The code above executes the request instantly and loads all items into the memory, thus we don't have the issue with multiple HTTP queries. The type of <code>filteredList</code> will be <code>IList</code>, not <code>IQueryable</code>.</p>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>  </body>
</html>