<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Extending the model for Microsoft Graph | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Extending the model for Microsoft Graph | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/plamber/pnpcore/blob/dev/docs/contributing/extending the model - Microsoft Graph.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="extending-the-model-for-microsoft-graph">Extending the model for Microsoft Graph</h1>

<p>The PnP Core SDK model contains model, collection, and complex type classes which are populated via either Microsoft Graph or SharePoint REST. In this chapter you'll learn more on how to decorate your classes and their properties to interact with Microsoft 365 via the Microsoft Graph API.</p>
<h2 id="configuring-model-classes">Configuring model classes</h2>
<h3 id="public-model-interface-decoration">Public model (interface) decoration</h3>
<p>All model classes need to link their concrete type (so the implementation) to the public interface via the <code>ConcreteType</code> class attribute:</p>
<pre><code class="lang-csharp">[ConcreteType(typeof(TeamChannel))]
public interface ITeamChannel : IDataModel&lt;ITeamChannel&gt;, IDataModelGet&lt;ITeamChannel&gt;, IDataModelLoad&lt;ITeamChannel&gt;, IDataModelUpdate, IDataModelDelete
{
    // Ommitted for brevity
}
</code></pre>
<h3 id="model-class-decoration">Model class decoration</h3>
<p>Each model class that uses Microsoft Graph needs to have at least one <code>GraphType</code> attribute:</p>
<pre><code class="lang-csharp">[GraphType(Uri = &quot;teams/{Site.GroupId}&quot;)]
internal partial class Team : BaseDataModel&lt;ITeam&gt;, ITeam
{
    // Ommitted for brevity
}
</code></pre>
<p>When configuring the <code>GraphType</code> attribute for Microsoft Graph you need to set the attribute properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Uri</td>
<td>No</td>
<td>Defines the URI that uniquely identifies this object. See <a href="model%20tokens.html">model tokens</a> to learn more about the possible tokens you can use.</td>
</tr>
<tr>
<td>Target</td>
<td>No</td>
<td>A model can be used from multiple scope and if so the <code>Target</code> property defines the scope of the <code>GraphType</code> attribute.</td>
</tr>
<tr>
<td>Id</td>
<td>No</td>
<td>Defines the Microsoft graph object field which serves as unique id for the object. Typically this field is called <code>id</code> and that's also the default value, but you can provide another value if needed.</td>
</tr>
<tr>
<td>Get</td>
<td>No</td>
<td>Overrides the Uri property for <strong>get</strong> operations.</td>
</tr>
<tr>
<td>LinqGet</td>
<td>No</td>
<td>Some model classes do support linq queries which are translated in corresponding server calls. If a class supports linq in this way, then it also needs to have the LinqGet attribute set.</td>
</tr>
<tr>
<td>Update</td>
<td>No</td>
<td>Overrides the Uri property for <strong>update</strong> operations.</td>
</tr>
<tr>
<td>Delete</td>
<td>No</td>
<td>Overrides the Uri property for <strong>delete</strong> operations.</td>
</tr>
<tr>
<td>OverflowProperty</td>
<td>No</td>
<td>Used when working with a dynamic property/value pair (e.g. fields in a SharePoint ListItem) whenever the Microsoft Graph field containing these dynamic properties is not named <code>Values</code>.</td>
</tr>
<tr>
<td>Beta</td>
<td>No</td>
<td>Defines that a model can only be handled using the Microsoft Graph beta endpoint. If a user opted out of using the Microsoft Graph beta endpoint then this model will not be populated.</td>
</tr>
</tbody>
</table>
<h3 id="property-decoration">Property decoration</h3>
<p>The property level decoration is done using the <code>GraphProperty</code> and <code>KeyProperty</code> attributes. Each model instance requires to have an override of the <code>Key</code> property and that <code>Key</code> property <strong>must</strong> be decorated with the <code>KeyProperty</code> attribute which specifies which of the actual fields in the model must be selected as key. The key is for example used to ensure there are no duplicate model class instances in a single collection.</p>
<p>Whereas the <code>KeyProperty</code> attribute is always there once in each model class, the usage of the <code>GraphProperty</code> attribute is only required for special cases.</p>
<pre><code class="lang-csharp">// In graph the fieldname is &quot;name&quot; whereas in the model the name is &quot;Title&quot;
[GraphProperty(&quot;name&quot;)]
public string Title { get =&gt; GetValue&lt;string&gt;(); set =&gt; SetValue(value); }

// Mark the property that serves as Key field
// (used to ensure there are no duplicates in collections),
// use a JsonPath to get the specific value you need
[GraphProperty(&quot;sharepointIds&quot;, JsonPath = &quot;webId&quot;)]
public Guid Id { get =&gt; GetValue&lt;Guid&gt;(); set =&gt; SetValue(value); }

// Define a collection as expandable
[GraphProperty(&quot;lists&quot;, Expandable = true)]
public IListCollection Lists { get =&gt; GetModelCollectionValue&lt;IListCollection&gt;(); }

// Configure an additional query to load this model class this is a non expandable collection
[GraphProperty(&quot;channels&quot;, ExpandByDefault = true, Get = &quot;teams/{Site.GroupId}/channels&quot;)]
public ITeamChannelCollection Channels { get =&gt; GetModelCollectionValue&lt;ITeamChannelCollection&gt;(); }

// Set the keyfield for this model class
[KeyProperty(nameof(Id))]
public override object Key { get =&gt; Id; set =&gt; Id = Guid.Parse(value.ToString()); }
</code></pre>
<p>You can set following properties on this attribute:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>FieldName</td>
<td>Yes</td>
<td>Use this property when the Microsoft Graph fieldname differs from the model property name. Since the field name is required by the default constructor you always need to provide this value when you add this property.</td>
</tr>
<tr>
<td>JsonPath</td>
<td>No</td>
<td>When the information returned from Microsoft Graph is a complex type and you only need a single value from it, then you can specify the JsonPath for that value. E.g. when you get sharePointIds.webId as response you tell the model that the fieldname is sharePointIds and the path to get there is webId. The path can be more complex, using a point to define property you need (e.g. property.child.childofchild). Using <code>JsonPath</code> can be a good alternative over using a Complex Type classes if your scenario only requires to reading some properties.</td>
</tr>
<tr>
<td>Expandable</td>
<td>No</td>
<td>Defines that a collection is expandable, meaning it can be loaded via the $expand query parameter and used in the lambda expression in <code>Get</code> and <code>GetAsync</code> operations.</td>
</tr>
<tr>
<td>ExpandByDefault</td>
<td>No</td>
<td>When the model contains a collection of other model objects then setting this attribute to true will automatically result in the population of that collection. This can negatively impact performance, so only set this when the collection is almost always needed.</td>
</tr>
<tr>
<td>Get</td>
<td>No</td>
<td>Sometimes it is not possible to load the complete model via a single Microsoft Graph request, often this is the case with collections (so the collection is <strong>not</strong> expandable). In this case you need to explain how to load the collection via specifying the needed query. See <a href="model%20tokens.html">model tokens</a> to learn more about the possible tokens you can use.</td>
</tr>
<tr>
<td>UseCustomMapping</td>
<td>No</td>
<td>Allows you to force a callout to the model's <code>MappingHandler</code> event handler whenever this property is populated. See the <a href="event%20handlers.html">Event Handlers</a> article to learn more.</td>
</tr>
<tr>
<td>Beta</td>
<td>No</td>
<td>Defines that a model property can only be handled using the Microsoft Graph beta endpoint. If a user opted out of using the Microsoft Graph beta endpoint, then this model property will not be populated.</td>
</tr>
</tbody>
</table>
<h2 id="configuring-collection-classes">Configuring collection classes</h2>
<h3 id="public-model-interface-decoration-1">Public model (interface) decoration</h3>
<p>All model collection classes need to link their concrete type (so the implementation) to the public interface via the <code>ConcreteType</code> class attribute:</p>
<pre><code class="lang-csharp">[ConcreteType(typeof(TeamChannelCollection))]
public interface ITeamChannelCollection : IQueryable&lt;ITeamChannel&gt;, IDataModelCollection&lt;ITeamChannel&gt;, IDataModelCollectionLoad&lt;ITeamChannel&gt;, IDataModelCollectionDeleteByStringId
{
    // Omitted for brevity
}
</code></pre>
<h2 id="implementing-add-functionality">Implementing &quot;Add&quot; functionality</h2>
<p>In contradiction with get, update, and delete which are fully handled by decorating classes and properties using attributes, you'll need to write actual code to implement add. Adding is implemented as follows:</p>
<ul>
<li><p>The public part (interface) is defined on the collection interface. Each functionality (like Add) is implemented via three methods:</p>
<ul>
<li>An async method</li>
<li>An async batch method</li>
<li>An async batch method that allows to pass in a <code>Batch</code> as first method parameter</li>
<li>A sync method that calls the async method with a <code>GetAwaiter().GetResult()</code></li>
<li>A sync batch method that calls the async method with a <code>GetAwaiter().GetResult()</code></li>
<li>A sync batch method that calls the async method with a <code>GetAwaiter().GetResult()</code> and allows to pass in a <code>Batch</code> as first method parameter</li>
</ul>
</li>
<li><p>Add methods defined on the interface are implemented in the collection classes as proxies that call into the respective add methods of the added model class</p>
</li>
<li><p>The implementation that performs the actual add is implemented as an <code>AddApiCallHandler</code> event handler in the model class. See the <a href="event%20handlers.html">Event Handlers</a> page for more details.</p>
</li>
</ul>
<p>Below code snippets show the above three concepts. First one shows the collection interface (e.g. ITeamChannelCollection.cs) with the Add methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Public interface to define a collection of Team Channels
/// &lt;/summary&gt;
[ConcreteType(typeof(TeamChannelCollection))]
public interface ITeamChannelCollection : IQueryable&lt;ITeamChannel&gt;, IDataModelCollection&lt;ITeamChannel&gt;, IDataModelCollectionLoad&lt;ITeamChannel&gt;, IDataModelCollectionDeleteByStringId
{
    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public Task&lt;ITeamChannel&gt; AddAsync(string name, string description = null);

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public ITeamChannel Add(string name, string description = null);

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;batch&quot;&gt;Batch to use&lt;/param&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public Task&lt;ITeamChannel&gt; AddBatchAsync(Batch batch, string name, string description = null);

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;batch&quot;&gt;Batch to use&lt;/param&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public ITeamChannel AddBatch(Batch batch, string name, string description = null);

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public Task&lt;ITeamChannel&gt; AddBatchAsync(string name, string description = null);

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public ITeamChannel AddBatch(string name, string description = null);
}
</code></pre>
<p>Implementation of the interface in the collection class (e.g. TeamChannelCollection.cs):</p>
<pre><code class="lang-csharp">internal partial class TeamChannelCollection : QueryableDataModelCollection&lt;ITeamChannel&gt;, ITeamChannelCollection
{
    public TeamChannelCollection(PnPContext context, IDataModelParent parent, string memberName = null)
        : base(context, parent, memberName)
    {
        this.PnPContext = context;
        this.Parent = parent;
    }

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public async Task&lt;ITeamChannel&gt; AddAsync(string name, string description = null)
    {
        if (string.IsNullOrEmpty(name))
        {
            throw new ArgumentNullException(nameof(name));
        }

        // TODO: validate name restrictions

        var newChannel = CreateNewAndAdd() as TeamChannel;

        // Assign field values
        newChannel.DisplayName = name;
        newChannel.Description = description;

        return await newChannel.AddAsync().ConfigureAwait(false) as TeamChannel;
    }

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public ITeamChannel Add(string name, string description = null)
    {
        return AddAsync(name, description).GetAwaiter().GetResult();
    }

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;batch&quot;&gt;Batch to use&lt;/param&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public async Task&lt;ITeamChannel&gt; AddBatchAsync(Batch batch, string name, string description = null)
    {
        if (string.IsNullOrEmpty(name))
        {
            throw new ArgumentNullException(nameof(name));
        }

        var newChannel = CreateNewAndAdd() as TeamChannel;

        // Assign field values
        newChannel.DisplayName = name;
        newChannel.Description = description;

        return await newChannel.AddBatchAsync(batch).ConfigureAwait(false) as TeamChannel;
    }

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;batch&quot;&gt;Batch to use&lt;/param&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public ITeamChannel AddBatch(Batch batch, string name, string description = null)
    {
        return AddBatchAsync(batch, name, description).GetAwaiter().GetResult();
    }

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public async Task&lt;ITeamChannel&gt; AddBatchAsync(string name, string description = null)
    {
        return await AddBatchAsync(PnPContext.CurrentBatch, name, description).ConfigureAwait(false);
    }

    /// &lt;summary&gt;
    /// Adds a new channel
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;Display name of the channel&lt;/param&gt;
    /// &lt;param name=&quot;description&quot;&gt;Optional description of the channel&lt;/param&gt;
    /// &lt;returns&gt;Newly added channel&lt;/returns&gt;
    public ITeamChannel AddBatch(string name, string description = null)
    {
        return AddBatchAsync(name, description).GetAwaiter().GetResult();
    }
}
</code></pre>
<p>And finally you'll see the actual add logic being implemented in the model class (e.g. TeamChannel.cs) via implementing the <code>AddApiCallHandler</code>:</p>
<pre><code class="lang-csharp">internal partial class TeamChannel : BaseDataModel&lt;ITeamChannel&gt;, ITeamChannel
{
    private const string baseUri = &quot;teams/{Parent.GraphId}/channels&quot;;

    internal TeamChannel()
    {
        // Handler to construct the Add request for this channel
        AddApiCallHandler = async (additionalInformation) =&gt;
        {
            // Define the JSON body of the update request based on the actual changes
            dynamic body = new ExpandoObject();
            body.displayName = DisplayName;
            if (!string.IsNullOrEmpty(Description))
            {
                body.description = Description;
            }

            // Serialize object to json
            var bodyContent = JsonSerializer.Serialize(body, typeof(ExpandoObject), new JsonSerializerOptions { WriteIndented = false });

            var apiCall = await ApiHelper.ParseApiRequestAsync(this, baseUri).ConfigureAwait(false);
            return new ApiCall(apiCall, ApiType.Graph, bodyContent);
        };
    }
}
</code></pre>
<h3 id="providing-additional-parameters-for-add-requests">Providing additional parameters for add requests</h3>
<p>The <code>AddApiCall</code> handler accepts an optional key value pair parameter: <code>Task&lt;ApiCall&gt; AddApiCall(Dictionary&lt;string, object&gt; additionalInformation = null)</code>. You can use this to provide additional input when you call the <code>Add</code> from your code in the collection class. Below sample shows how this feature is used to offer different SDK consumer methods for creating Team channel tabs (on the <code>TeamChannelTabCollection</code> class) while there's only one generic creation method implementation in the <code>TeamChannelTab</code> class. Let's start with the code in the <code>TeamChannelTabCollection</code> class:</p>
<pre><code class="lang-csharp">public async Task&lt;ITeamChannelTab&gt; AddWikiTabAsync(string name)
{
    if (string.IsNullOrEmpty(name))
    {
        throw new ArgumentNullException(nameof(name));
    }

    (TeamChannelTab newTab, Dictionary&lt;string, object&gt; additionalInformation) = CreateTeamChannelWikiTab(name);

    return await newTab.AddAsync(additionalInformation).ConfigureAwait(false) as TeamChannelTab;
}

public async Task&lt;ITeamChannelTab&gt; AddDocumentLibraryTabAsync(string name, Uri documentLibraryUri)
{
    if (string.IsNullOrEmpty(name))
    {
        throw new ArgumentNullException(nameof(name));
    }

    (TeamChannelTab newTab, Dictionary&lt;string, object&gt; additionalInformation) = CreateTeamChannelDocumentLibraryTab(name, documentLibraryUri);

    return await newTab.AddAsync(additionalInformation).ConfigureAwait(false) as TeamChannelTab;
}

private Tuple&lt;TeamChannelTab, Dictionary&lt;string, object&gt;&gt; CreateTeamChannelDocumentLibraryTab(string displayName, Uri documentLibraryUri)
{
    var newTab = CreateTeamChannelTab(displayName);

    Dictionary&lt;string, object&gt; additionalInformation = new Dictionary&lt;string, object&gt;
    {
        { &quot;teamsAppId&quot;, &quot;com.microsoft.teamspace.tab.files.sharepoint&quot; },
    };

    newTab.Configuration = new TeamChannelTabConfiguration
    {
        EntityId = &quot;&quot;,
        ContentUrl = documentLibraryUri.ToString()
    };

    return new Tuple&lt;TeamChannelTab, Dictionary&lt;string, object&gt;&gt;(newTab, additionalInformation);
}

private Tuple&lt;TeamChannelTab, Dictionary&lt;string, object&gt;&gt; CreateTeamChannelWikiTab(string displayName)
{
    var newTab = CreateTeamChannelTab(displayName);

    Dictionary&lt;string, object&gt; additionalInformation = new Dictionary&lt;string, object&gt;
    {
        { &quot;teamsAppId&quot;, &quot;com.microsoft.teamspace.tab.wiki&quot; }
    };

    return new Tuple&lt;TeamChannelTab, Dictionary&lt;string, object&gt;&gt;(newTab, additionalInformation);
}
</code></pre>
<p>The code in the <code>TeamChannelTab</code> class then uses the additional parameter values to drive the creation behavior:</p>
<pre><code class="lang-csharp">AddApiCallHandler = async (additionalInformation) =&gt;
{
    // Define the JSON body of the update request based on the actual changes
    dynamic tab = new ExpandoObject();
    tab.displayName = DisplayName;

    string teamsAppId = additionalInformation[&quot;teamsAppId&quot;].ToString();
    tab.teamsAppId = teamsAppId;

    switch (teamsAppId)
    {
        case &quot;com.microsoft.teamspace.tab.wiki&quot;: // Wiki, no configuration possible
            break;
        default:
            {
                tab.Configuration = new ExpandoObject();

                if (Configuration.IsPropertyAvailable&lt;ITeamChannelTabConfiguration&gt;(p=&gt;p.EntityId))
                {
                    tab.Configuration.EntityId = Configuration.EntityId;
                }
                if (Configuration.IsPropertyAvailable&lt;ITeamChannelTabConfiguration&gt;(p =&gt; p.ContentUrl))
                {
                    tab.Configuration.ContentUrl = Configuration.ContentUrl;
                }
                if (Configuration.IsPropertyAvailable&lt;ITeamChannelTabConfiguration&gt;(p =&gt; p.RemoveUrl))
                {
                    tab.Configuration.RemoveUrl = Configuration.RemoveUrl;
                }
                if (Configuration.IsPropertyAvailable&lt;ITeamChannelTabConfiguration&gt;(p =&gt; p.WebsiteUrl))
                {
                    tab.Configuration.WebsiteUrl = Configuration.WebsiteUrl;
                }
                break;
            }
    }

    // Serialize object to json
    var bodyContent = JsonSerializer.Serialize(tab, typeof(ExpandoObject), new JsonSerializerOptions { WriteIndented = false });

    var parsedApiCall = await ApiHelper.ParseApiRequestAsync(this, baseUri).ConfigureAwait(false);
    return new ApiCall(parsedApiCall, ApiType.GraphBeta, bodyContent);
};
</code></pre>
<h2 id="doing-additional-api-calls">Doing additional API calls</h2>
<p>Above example showed the <code>AddApiCallHandler</code> which provides a framework for doing add requests, but you often also need to do other types of requests and for that you need to be able to execute API calls. There are 2 ways to do this:</p>
<ul>
<li>Run an API call and automatically load the resulting API call response in the model</li>
<li>Run an API call and process the resulting JSON as part of your code</li>
</ul>
<p>Above methods are described in the next chapters.</p>
<h3 id="running-an-api-call-and-loading-the-result-in-the-model">Running an API call and loading the result in the model</h3>
<p>When you know that the API call you're making will return JSON data that has to be loaded into the model then you should use the <code>RequestAsync</code> method for immediate async processing or <code>Request</code> method for batch processing. These methods accept an <code>ApiCall</code> instance as input together with the <code>HttpMethod</code>.</p>
<pre><code class="lang-csharp">// to update
</code></pre>
<h3 id="running-an-api-call-and-processing-the-resulting-json-as-part-of-your-code">Running an API call and processing the resulting JSON as part of your code</h3>
<p>Some API calls do return data, but the returned data cannot be loaded into the current model. In those cases you should use the <code>RawRequestAsync</code> method. This method accepts an <code>ApiCall</code> instance as input together with the <code>HttpMethod</code>. Below sample shows how you can archive a Team. The sample shows how the <code>ApiCall</code> is built and executed via the <code>RawRequestAsync</code> method. This method returns an <code>ApiCallResponse</code> object that contains the http response code, the JSON response and additional response headers from the server, which is processed and as a result the recycle bin item id is returned and the list is removed from the model.</p>
<pre><code class="lang-csharp">public async Task&lt;ITeamAsyncOperation&gt; ArchiveAsync(bool setSPOSiteReadOnlyForMembers)
{
    if (Requested)
    {

        dynamic body = new ExpandoObject();
        body.shouldSetSpoSiteReadOnlyForMembers = setSPOSiteReadOnlyForMembers;

        var bodyContent = JsonSerializer.Serialize(body, typeof(ExpandoObject), new JsonSerializerOptions { WriteIndented = false });

        var apiCall = new ApiCall($&quot;teams/{Id}/archive&quot;, ApiType.Graph, bodyContent);

        var response = await RawRequestAsync(apiCall, HttpMethod.Post).ConfigureAwait(false);

        if (response.StatusCode == System.Net.HttpStatusCode.Accepted &amp;&amp; response.Headers != null &amp;&amp; response.Headers.ContainsKey(&quot;Location&quot;))
        {
            // The archiving operation is in progress, already set the Team IsArchived flag to true
            (this as ITeam).SetSystemProperty(p =&gt; p.IsArchived, true);

            // we get back a url to request a teamsAsyncOperation (https://docs.microsoft.com/en-us/graph/api/resources/teamsasyncoperation?view=graph-rest-beta)
            return new TeamAsyncOperation(response.Headers[&quot;Location&quot;], PnPContext);
        }
    }

    return null;
}
</code></pre>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>  </body>
</html>