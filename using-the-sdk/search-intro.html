<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Using search | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using search | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/plamber/pnpcore/blob/dev/docs/using-the-sdk/search-intro.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="using-search">Using search</h1>

<p>Using the search features of PnP Core SDK you can issue queries and process the returned search results.</p>
<p>In the remainder of this article you'll see a lot of <code>context</code> use: in this case this is a <code>PnPContext</code> which was obtained via the <code>PnPContextFactory</code> as explained in the <a href="readme.html">overview article</a> and show below:</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // See next chapter on how to use the PnPContext for working with files
}
</code></pre>
<h2 id="making-a-basic-search-request">Making a basic search request</h2>
<p>Let's start with making a simple search request by using one of the <code>Search</code> methods on <code>IWeb</code>. When making a search request you specify the search query and related options via a <code>SearchOptions</code> object as shown in below snippet. The key input for a search request is the actual search query (<code>contenttypeid:&quot;0x010100*&quot;</code> in below sample) and you can learn more about how to construct that query from <a href="https://docs.microsoft.com/en-us/sharepoint/dev/general-development/keyword-query-language-kql-syntax-reference">here</a>.</p>
<p>The returned search result rows are in form of a <code>Dictionary&lt;string, object&gt;</code> with the search result property name as key and the search result property value as value.</p>
<pre><code class="lang-csharp">// Let's search for all lists using a particular content type and
// for the found rows return the listed &quot;select&quot; properties
SearchOptions searchOptions = new SearchOptions(&quot;contenttypeid:\&quot;0x010100*\&quot;&quot;)
{
    TrimDuplicates = false,
    SelectProperties = new System.Collections.Generic.List&lt;string&gt;() { &quot;Path&quot;, &quot;Url&quot;, &quot;Title&quot;, &quot;ListId&quot; },
};

var searchResult = await context.Web.SearchAsync(searchOptions);

foreach (var result in searchResult.Rows)
{
    if (result[&quot;Title&quot;] == &quot;abc&quot;)
    {
        // Do something
    }
}
</code></pre>
<h2 id="sorting-the-search-results">Sorting the search results</h2>
<p>Often you want to also sort the search results on one or more properties and this is supported via the <code>SortProperties</code> attribute of the <code>SearchOptions</code> class. Checkout this <a href="https://docs.microsoft.com/en-us/sharepoint/dev/general-development/sorting-search-results-in-sharepoint">documentation</a> to learn more about the sort options offered by search.</p>
<pre><code class="lang-csharp">SearchOptions searchOptions = new SearchOptions(&quot;contenttypeid:\&quot;0x010100*\&quot;&quot;)
{
    TrimDuplicates = false,
    SelectProperties = new System.Collections.Generic.List&lt;string&gt;() { &quot;Path&quot;, &quot;Url&quot;, &quot;Title&quot;, &quot;ListId&quot; },
    // Define the properties to use for sorting the results, sorting on DocId a best practice
    // to increase search query performance
    SortProperties = new System.Collections.Generic.List&lt;SortOption&gt;()
    {
        new SortOption(&quot;DocId&quot;),
        new SortOption(&quot;ModifiedBy&quot;, SortDirection.Ascending)
    },
};

var searchResult = await context.Web.SearchAsync(searchOptions);
</code></pre>
<h2 id="getting-refiners-for-the-returned-search-results">Getting refiners for the returned search results</h2>
<p>When making a search request you can also ask the search engine to refine the search results on one or more refiners. Refiners are managed properties that are marked as refinable in the search schema and when used you'll get next to the actual search results also a result set per refiner showing you how the returned search results are grouped based upon the refiner. Checkout this <a href="https://docs.microsoft.com/en-us/sharepoint/dev/general-development/query-refinement-in-sharepoint">documentation</a> to learn more about refiners. An example will provide more clarity: using below code we'll query all document libraries in the tenant and refine on <code>contenttypeid</code>. As a result you'll get a list of all document libraries in the search results and in the refinements you'll get a break down per <code>contenttypeid</code>, you'll see that for <code>contenttypeid</code> x there are y libraries using it, for <code>contenttypeid</code> Z there are n libraries using it, ...</p>
<pre><code class="lang-csharp">SearchOptions searchOptions = new SearchOptions(&quot;contentclass:STS_ListItem_DocumentLibrary&quot;)
{
    TrimDuplicates = false,
    SelectProperties = new System.Collections.Generic.List&lt;string&gt;() { &quot;Path&quot;, &quot;Url&quot;, &quot;Title&quot;, &quot;ListId&quot; },
    SortProperties = new System.Collections.Generic.List&lt;SortOption&gt;() { new SortOption(&quot;DocId&quot;) },
    RefineProperties = new System.Collections.Generic.List&lt;string&gt;() { &quot;ContentTypeId&quot; }
};

var searchResult = await context.Web.SearchAsync(searchOptions);

// Process the search results
foreach (var result in searchResult.Rows)
{
    if (result[&quot;Title&quot;] == &quot;abc&quot;)
    {
        // Do something
    }
}

// Process the refiner results
foreach (var refiner in searchResult.Refinements)
{
    foreach (var refinementResult in refiner.Value)
    {
        // refinementResult.Value is a possible refinement value
        // refinementResult.Count will provide the number of counts for the refinement value
    }
}
</code></pre>
<h2 id="refining-search-results-using-refinement-filters">Refining search results using refinement filters</h2>
<p>The following example shows how to create a search request by passing the first refinement option obtained from the previous example search result. Set the <code>RefinementFilters</code> property to a list of KQL queries, which can be built up using the <code>Token</code> from previous refinement results.</p>
<pre><code class="lang-csharp">// Retrieve the refinement
var refinementResults = searchResult.Refinements[&quot;ContentTypeId&quot;];
var refinementToken = refinementResults[0].Token;

SearchOptions searchOptions = new SearchOptions(&quot;contentclass:STS_ListItem_DocumentLibrary&quot;)
{
    RefinementFilters = new System.Collections.Generic.List&lt;string&gt;() { $&quot;ContentTypeId:{refinementToken}&quot; }
};

// Issue the search query
var searchResult = await context.Web.SearchAsync(searchOptions);

</code></pre>
<h2 id="paging-the-search-results">Paging the search results</h2>
<p>By default search results are returned in pages of 500, something you can change via the <code>RowsPerPage</code> attribute of the <code>SearchOptions</code> class. When a search query returns you'll be informed of the total amount of search results there are via the <code>TotalRows</code> and <code>TotalRowsIncludingDuplicates</code> properties of the <code>ISearchResult</code> response. Using these properties in concert with the <code>StartRow</code> property of the <code>SearchOptions</code> class you retrieve all the search result pages. Below sample shows how this can be done.</p>
<pre><code class="lang-csharp">List&lt;Dictionary&lt;string, object&gt;&gt; searchResults = new List&lt;Dictionary&lt;string, object&gt;&gt;();

bool paging = true;
int startRow = 0;

while (paging)
{
    SearchOptions searchOptions = new SearchOptions(&quot;contenttypeid:\&quot;0x010100*\&quot;&quot;)
    {
        StartRow = startRow,
        TrimDuplicates = false,
        SelectProperties = new System.Collections.Generic.List&lt;string&gt;() { &quot;Path&quot;, &quot;Url&quot;, &quot;Title&quot;, &quot;ListId&quot; },
        SortProperties = new System.Collections.Generic.List&lt;SortOption&gt;()
        {
            new SortOption(&quot;DocId&quot;),
            new SortOption(&quot;ModifiedBy&quot;, SortDirection.Ascending)
        },
    };

    // Issue the search query
    var searchResult = await context.Web.SearchAsync(searchOptions);

    // Add the returned page of results to our search results list
    searchResults.AddRange(searchResult.Rows);

    // If we're not done yet update the start row and issue a query to retrieve the next page
    if (searchResults.Count &lt; searchResult.TotalRows)
    {
        startRow = searchResults.Count;
    }
    else
    {
        // We're done!
        paging = false;
    }
}

// Process the total search result set
foreach (var result in searchResults)
{
    if (result[&quot;Title&quot;] == &quot;abc&quot;)
    {
        // Do something
    }
}
</code></pre>
<h2 id="batching-search-queries">Batching search queries</h2>
<p>PnP Core SDK also allows you to batch multiple search queries and send them in one operation to the server, this can be done by using one of the <code>SearchBatch</code> methods.</p>
<pre><code class="lang-csharp">var batch = context.NewBatch();
Dictionary&lt;Guid, IBatchSingleResult&lt;ISearchResult&gt;&gt; batchResults =
    new Dictionary&lt;Guid, IBatchSingleResult&lt;ISearchResult&gt;&gt;();

List&lt;Guid&gt; uniqueListIds = new List&lt;Guid&gt;();
// Imagine the uniqueListIds contains a series of list id's that you want to issue a search query for

foreach (var listId in uniqueListIds)
{
    // Issue a search query with a refinement on `contenttypeid`, we don't need the
    // result rows, so `RowLimit` is set to 0
    var request = await context.Web.SearchBatchAsync(batch, new SearchOptions($&quot;listid:{listId}&quot;)
    {
        RowLimit = 0,
        SortProperties = new List&lt;SortOption&gt;() { new SortOption(&quot;DocId&quot;) },
        RefineProperties = new List&lt;string&gt; { &quot;contenttypeid&quot; },
    });
    // Track the search query batch result objects
    batchResults.Add(listId, request);
}

// Execute the batch
await context.ExecuteAsync(batch);

// Process the search results
foreach (var batchResult in batchResults)
{
    // Check the IsAvailable attribute to ensure the search request was executed
    if (batchResult.Value.IsAvailable)
    {
        // The Result property is of type ISearchResult and can be used to process the search results
        if (batchResult.Value.Result.Refinements.Count &gt; 0 &amp;&amp;
            batchResult.Value.Result.Refinements.ContainsKey(&quot;contenttypeid&quot;))
        {
            foreach (var refinementResult in batchResult.Value.Result.Refinements[&quot;contenttypeid&quot;])
            {
                // Process the contenttypeid refiner results
            }
        }
    }
}
</code></pre>
<h2 id="re-indexing-webs-and-lists">Re-indexing webs and lists</h2>
<p>When you make <a href="https://docs.microsoft.com/en-us/sharepoint/crawl-site-content">changes to the search schema (e.g. updated managed properties)</a> then you'll need to re-index the relevant content, which can be done at <a href="lists-intro.html#re-indexing-a-list">list level</a> or <a href="webs-intro.html#re-indexing-a-web">web level</a>.</p>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>  </body>
</html>