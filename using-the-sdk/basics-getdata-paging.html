<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Using paging | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using paging | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/plamber/pnpcore/blob/dev/docs/using-the-sdk/basics-getdata-paging.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="using-paging">Using paging</h1>

<p>Being able to retrieve data in a paged manner is important when you want to use the first data rows while you're loading still additional data, but also when you're loading large data sets. When you page data you can start from a LINQ query or from a whole collection of items. Either way, PnP Core SDK provides you &quot;implicit paging&quot;, meaning that when you browse (for example with a <code>foreach</code> constructor) the items in the collection, under the cover PnP Core SDK will retrieve data page by page, giving you back data like it was already in memory (continuous querying with implicit paging).
If you rather want to have full control on paging data, you can use the <code>Take()</code> method and from that point on PnP Core SDK will handle paging for you.</p>
<div class="NOTE">
<h5>Note</h5>
<p>In the remainder of this article you'll see a lot of <code>context</code> use: in this case this is a <code>PnPContext</code> which was obtained via the <code>PnPContextFactory</code> as explained in the <a href="readme.html">overview article</a> and show below:</p>
</div>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // See next chapter on how to use the PnPContext for getting paged data
}
</code></pre>
<h2 id="implicit-paging">Implicit paging</h2>
<p>In this example the messages in a Team channel are queried continuously, using implicit paging. When doing so the underlying Graph API call will return a &quot;next page link&quot; automatically and if so this will be used to get the next messages. The paging dynamics will be completely transparent to you, and you will simply get back the data that you are looking for, with an optimized and paged querying approach.</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // Retrieve the already created channel
    var channelForPaging2 = context.Team.Channels.FirstOrDefault(p =&gt; p.DisplayName == &quot;My Channel&quot;);

    // Retrieve the messages page by page and asynchronously in a transparent way 
    await foreach(var message in channelForPaging2.Messages)
    {
        // do something with the message
    }
}
</code></pre>
<p>As you can see, you can just focus on consuming data, while under the cover PnP Core SDK will retrieve the items for you, page by page, optimizing bandwidth and requests. Notice the <code>await</code> keyword just before the <code>foreach</code> constructor, in order to make the continuous query fully asynchronous and highly optimized. This is the suggested pattern for consuming large collections of items.</p>
<p>If your query needs to apply filters or properties selection on the queried data, you can leverage the <code>AsAsyncEnumerable</code> method to keep the query asynchronous and paged with continuous implicit paging. Here is an example.</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // Efficient, dynamic and asynchronous with whatever LINQ query you like
    await foreach(var list in context.Web.Lists.Where(l =&gt; l.Title == &quot;Documents&quot;).AsAsyncEnumerable())
    {
        // do something with the list
    }
}
</code></pre>
<p>If your code is not asynchronous, and as such you cannot rely on the <code>await</code> keyword just before the <code>foreach</code> constructor, you can still use the synchronous enumeration of items, like it is illustrated in the following sample.</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // Retrieve the already created channel
    var channelForPaging2 = context.Team.Channels.FirstOrDefault(p =&gt; p.DisplayName == &quot;My Channel&quot;);

    // Retrieve the messages page by page, synchronously in a transparent way 
    foreach(var message in channelForPaging2.Messages)
    {
        // do something with the message
    }
}
</code></pre>
<p>You will still get the whole set of items (messages in the previous example) with multiple REST queries page by page. However, the querying of all the items will be synchronous and your code will be blocked while waiting for the whole set of items to be queried. This is a sub-optimal scenario, that you should try to avoid, preferring the asynchronous model.</p>
<h2 id="full-load-of-items">Full load of items</h2>
<p>Another option that you have is to load in memory the whole set of items, using any of the <code>Load</code> methods available in PnP Core SDK. In the following sample, you can see how to load in memory the whole set of messages of a Teams channel.</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // Retrieve the already created channel
    var channelForPaging2 = context.Team.Channels.FirstOrDefault(p =&gt; p.DisplayName == &quot;My Channel&quot;);

    // Load the messages, this will load all messages via paged requests
    await channelForPaging2.LoadAsync(p =&gt; p.Messages);

    // Consume the in-memory items 
    foreach(var message in channelForPaging2.Messages.AsRequested())
    {
        // do something with the message
    }
}
</code></pre>
<p>The <code>AsRequested</code> method will browse the already in-memory items. The items will be loaded just once by the <code>Load</code> method.</p>
<h2 id="paging-via-the-takeskip-extension-methods">Paging via the Take()/Skip() extension methods</h2>
<p>If you want to have full control on paging data, you can rely on the <code>Take</code>/<code>Skip</code> extension methods. In the following example you can see how to use manual paging to load lists.</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // Get a first page of lists of size 2
    var lists = await context.Web.Lists.Take(2).QueryProperties(p =&gt; p.Title).ToListAsync();

    // Get the next page
    lists = await context.Web.Lists.Take(2).Skip(2).QueryProperties(p =&gt; p.Title).ToListAsync();    
}
</code></pre>
<p>In the above sample only the <code>Title</code> property of the lists is requested, if you do not provide the expression then the list default properties are loaded.</p>
<p>In the following code excerpt you can see a complete logic to manually page items in a collection using <code>Take</code>/<code>Skip</code> extension methods.</p>
<pre><code class="lang-csharp">int pageCount = 0;
int pageSize = 10;

while (true)
{
    var page = context.Web.Lists.Skip(pageSize * pageCount).Take(pageSize).ToArray();
    
    // Use the current page ...

    pageCount++;
    if (page.Length &lt; pageSize)
    {
        break;
    }
}
</code></pre>
<p>Notice that the above sample relies on you for requesting the pages. As such, unless you really need to manually control paging, you should avoid this approach and rather use the continuous paging with asynchronous code.</p>
<h3 id="using-take-extension-method-with-a-filter-and-complex-data-load-expression">Using Take() extension method with a filter and complex data load expression</h3>
<p>This example builds on top of the previous but shows some additional capabilities:</p>
<ul>
<li>A complex expression is used to define which List properties to load</li>
<li>A filter expression is specified so that only a subset of lists are returned</li>
<li>The returned, paged, data is made available via the method call output</li>
</ul>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // Get a first page of lists of size 2 
    //   filtered to generic lists
    //     returning list properties
    //     - Title and TemplateType
    //     - ContentTypes
    //          - For each content type the FieldLinks loaded
    //               - For each FieldLink the Name property
    var lists = await context.Web.Lists.Take(2)
                                        .Where(p =&gt; p.TemplateType == ListTemplateType.GenericList)
                                        .QueryProperties(p =&gt; p.Title, p =&gt; p.TemplateType,
                                                        p =&gt; p.ContentTypes.QueryProperties(
                                                        p =&gt; p.Name, p =&gt; p.FieldLinks.QueryProperties(p =&gt; p.Name)))
                                        .ToListAsync();
}
</code></pre>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>  </body>
</html>